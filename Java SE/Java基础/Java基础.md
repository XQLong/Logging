## 一、数据类型和内存

Java最重要的特性之一就是它的内存分配系统。

**原始数据类型：**

|类型|所占字节|
|-|-|
|byte|1|
|boolean|1|
|char|2|
|int|4|
|float|4|
|double|8|
|long|8|

- 整型：byte、short、int、long四种。最高位一位符号位，其他数值位。
- 字符型：采用Unicode字符集作为编码方式（计算机底层保存该字符时，保存的为该字符的编号），范围'\u0000~\uFFFF'，其中前256个从'\u0000~\u00FF'与ASCII码字符完全重合。
- 浮点型：float和double两种。采用二进制的科学计数法来表示浮点数。对于float，第一位是符号位，接下来八位是指数，接下来的23位表示尾数；对于double类型的数值，第一位也是符号位，接下来的11位表示指数，再接下来的52位表示尾数。
- 布尔型：不能与其它基础类型数据进行转换。虽然boolean类型的便令只需要

**对象所占用的内存：**

- 对象占用内存 = 所用实例变量的内存+对象本身的开销
- 对象本身的开销一般是16字节，包括一个指向对象的类的引用、垃圾收集及同步信息。
- 入一个Integer对象占用的内存：对象本身的开销16字节+保存int值4字节+填充4字节=24字节

**数组**

原始数据类型的数组一般需要24字节的头信息（16字节的对象开销和4字节用于保存长度以及4字节的填充）。
例如一个含有N个int值的数组需要使用（24+4*N）字节，含有N个double值的数组需要（24+8*N）字节。

**字符串对象**

String标准实现的4个实例变量：一个指向字符数组的引用（8字节）和三个int值（各占用4个字节，分别是字符数组的偏移量，字符数组的长度和一个散列值）

除字符数组之外字符串所需要的内存空间（16字节表示对象，三个int实例变量12字节，8字节数组引用和4个字节填充）。

40字节+（24+2*N）字节 = 64+2*N字节

Java对字符串的表示能够避免重复字符串中的字符，当调用substring（）方法时，就创建了一个新的String对象（40字节），它仍然使用了相同的value[]数组，因此该字符串的子字符串只会使用40字节的内存。

**包装类型**

基本类型都有对应的包装类型，基本类型与其对应的封装类型之间的赋值使用自动装箱与拆箱完成。

## 二、运算

**参数传递**
Java中的参数传递是以值传递的形式传入方法中，而不是引用传递。

**隐式类型转换**
Java不能隐式执行向下转换，因为这样会降低精度。当不作声明的时候，默认的小数都采用double数据类型，如果需要采用float的话，则应该在其后加上f。、

Java表达式转型规则由低到高转换：
1、所有的byte,short,char型的值将被提升为int型；
2、如果有一个操作数是long型，计算结果是long型；
3、如果有一个操作数是float型，计算结果是float型；
4、如果有一个操作数是double型，计算结果是double型；
5、被fianl修饰的变量不会自动改变类型，当2个final修饰相操作时，结果会根据左边变量的类型而转化。


**异或运算**
“^”按二进制的形式求取异或运算有两个性质：
- 任何数与自身的异或为0；
- 任何数与0的异或为自身。
常常采用异或运算来进行不借用第三个中间变量的条件下交换两个数的值。


## 三、继承

**访问权限**

三个访问权限修饰符：private、protected、public，不加访问修饰符表示包级可见。

<div align="center">

![title](https://raw.githubusercontent.com/XQLong/Logging/master/img/2019/07/22/1563784677899-1563784678106.png)

</div>

protected用于修饰成员（对类没有意义），表示继承体系中成员对子类可见。如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别（确保满足里氏替换原则，即可以使用父类实例的地方都可以使用子类实例）。

**抽象类与接口**
 
抽象类和抽象方法都是用abstract关键词修饰，抽象方法一定位于抽象类中；抽象类不能实例化，需要继承抽象类才能实例化其子类。

接口是抽象类的延伸，在Java8之前它可以看作一个完全抽象的类；从Java8开始，接口也可以拥有默认的方法实现。在接口里面的变量默认都是public static final的，它们是公共的，静态的，最终的常量，相当于全局常量，可以直接省略修饰符。实现类可以直接访问接口中的变量。

- 抽象类的特点：
1. 抽象类中可以有构造方法；
2. 抽象类中可以有普通属性，方法，静态属性和方法；
3. 抽象类中可以存在抽象方法。如果一个类中存在抽象方法则该类一定是抽象类，但是抽象类中不一定有抽象方法；
4. 抽象类中的抽象方法，需要有子类实现，如果子类不实现，则子类也需要定义为抽象的。

- 接口的特点：
1. 在接口中只有方法的声明，没有方法体；
2. 在接口中只有常量，因为定义的变量，在编译时会默认加上public static final修饰；
3. 在接口中的方法永远都被public来修饰；
4. 接口中没有构造方法，也不能实例化接口的对象；
5. 接口可以实现多继承；
6. 接口中定义的方法都需要实现类来实现，如果实现类不实现接口中的所有方法，则实现类定义为抽象类。

抽象类和接口的比较：
- 从设计层面上来看，抽象类提供了一种IS-A的关系，那么就必须满足里氏替换原则，即子类对象必须能够替换掉所有父类对象；而接口则更像是一种LIKE-A的关系，它只是提供一种方法实现上的契约，并不要求接口和实现接口的类具有IS-A关系；
- 从使用上看，一个类可以实现多个接口，但不能继承多个抽象类；
- 接口的字段只能是public static fianl的，而抽象类的字段没有这种限制；

**Super**

- 访问父类的构造函数：可以使用super（）函数完场，从而委托父类完成一些初始化的工作。
- 访问父类的成员：如果子类重写了父类的某个方法，可以通过super关键字来引用父类的方法实现。

## 4、Object通用方法

### equals()

满足自反性、对称性、传递性、一致性；
等价与相等的比较：
- 对于基本类型，==判断两个值是否相等，基本类型没有equals()方法；
- 对于引用类型，==判断两个变量是否引用了同一个对象，而equals()判断引用的对象是否等价。

### hashcode()

hashcode()返回散列值，而equals（）是用来判断两个对象是否等价。等价的两个对象的散列值一定相同，但散列值相同的两个对象不一定等价。

### clone()

- Cloneable：
clone()是Object的protected方法，它不是public，一个类不显式去重写clone()，其他类就不能直接调用该类实例的clone()方法。
- 浅拷贝：
拷贝对象和原始对象的引用类型引用同一个对象；
- 深拷贝：
拷贝对象的引用和原始对象的引用类型引用不同对象。











# Java并发

## 一、线程概述

进程是处于运动过程中的程序，是系统进行资源分配和调度的一个独立单元。具有如下特征：

- 独立性
- 动态性
- 并发性：多个进程可在单个处理器上并发执行，多个进程间不互相影响。

线程也被称为轻量级进程，线程是进程的执行单元。线程的执行是抢占式的；一个线程可以创建和撤销另一个线程，同一个进程中多个线程可以并发执行。

## 二、线程的创建和启动

### 2.1 通过继承Thread类

- 定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务。因此把run()方法称为线程的执行体；
- 创建子类的实例，即创建了线程对象；
- 调用线程对象的start()方法来启动该线程；

使用继承Thread类的方法来创建线程时，多个线程之间无法共享线程类的实例变量。

### 2.2 实现Runnable接口
- 定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法同样是线程的执行体；
- 创建Runnable实现类的实例，并以此作为Thread的Target来创建Thread对象，该Thread对象才是真正的线程对象；
- 调用线程对象的start()方法来启动该线程。

采用Runnable接口的方式创建的多个线程可以共享线程类的实例变量（多个线程共享线程的target）。

### 2.3 使用Callable和Future
- 创建Callable接口的实现类，并实现Call()方法，该call()方法将作为线程执行体，且该caLL()方法有返回值，再创建Callable类的实例；
- 使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()返回值；
- 使用FutureTask对象作为Thread的target来创建并启动新线程；
- 调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。

### 2.4 创建线程的三种方法的对比

实现Runnable和Callable接口的方式基本相同，知识Callable接口定义的方法有返回值，可以声明抛出异常。可以将实现Runnable接口和实现Callable接口归为一类方式。

实现Runnable、Callable接口方式创建多线程的优缺点：

- 线程类只实现了Runnable和Callable接口，还可以继承其他类；
- 在这种方式下，多个线程可以共享一个target对象，所以非常适合多个线程同时处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。

采用继承Thread类的方式创建多线程的优缺点：

- 劣势是因为线程类已经继承了Thread类而不能再继承其他类；
- 优势是编写简单，可直接使用this获取当前线程。

## 三、线程的生命周期

![title](https://raw.githubusercontent.com/XQLong/Image-Hosting/master/gitnote/2019/08/14/1565785133309-1565785133663.png)

### 3.1 新建和就绪状态

当程序使用new关键字创建了一个线程后，该线程就处于新建状态，此时它和其它java对象一样，仅仅由Java虚拟机为其分配内存，并初始化其成员变量的值。此时的线程对象没有表现出任何线程的动态特征，程序也不会执行线程的执行体。

当线程对象调用了start()方法后，该线程就处于就绪状态，Java虚拟机会为其创建方法调用栈和程序计数器，处于这个状态中的线程并没有开始运行，只是表示该线程可以运行了。至于何时开始运行取决于JVM里线程调度器的调度。

### 3.2 运行和阻塞状态

如果处于就绪状态的线程得到了CPU，开始执行run()方法中线程的执行体，则线程处于运行状态。当一个线程开始运行后，它不可能一直处于运行状态（除非线程的执行时间足够短，瞬间就执行结束了），线程在执行过程中会被中断，目的是使其他的线程得到执行的机会，线程的调度细节取决于底层平台采用的策略。

如果发生如下情况时，线程会进入阻塞状态：

- 线程使用sleep()方法主动放弃所占用的处理器资源；
- 线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞；
- 线程试图获得一个同步监视器，但该同步监视器正被其他线程所持有；
- 线程在等待某个通知（notify）；
- 程序调用了线程的suspend()方法将线程挂起。但这个方法容易导致锁死，应尽量避免使用该方法。

当发生如下的定情况时可以解除上面的阻塞，让线程重新进入就绪状态：
- 调用sleep()方法的线程已经过了指定的时间；
- 线程调用的阻塞式IO方法已经返回；
- 线程已成功获得了试图取的同步监视器；
- 线程正在等待通知时其他线程发出了一个通知；
- 处于挂起状态的线程被调用了resume()方法。

### 3.3线程死亡

线程会以如下三种方式结束，结束后就处于死亡状态：
- run()或call()方法执行完成，线程正常结束；
- 线程抛出一个未捕获的Exception或Error；
- 直接调用该线程的stop()方法来结束该线程——该方法容易导致锁死，通常不推荐使用。

调用线程对象的isAlive()方法可以测试某个线程是否死亡，当线程处于就绪、运行、阻塞状态时该方法返回true；当线程处于新建、死亡两种状态时，该方法返回false。

## 四、控制线程

### 4.1 join线程

join()方法——让一个线程等待另一个线程完成的方法。当某个程序执行流中调用其他线程的join()方法时，调用线程将被阻塞，直到join()方法加入的线程执行完成为止。

```
public class JoinThread extends Thread{
    //提供一个有参数的构造器，用来设置该线程的名字
    public JoinThread(String name){
        super(name);
    }
    //重写run()方法定义线程执行体
    public void run(){
        for(int i = 0;i<100;i++){
            System.out.println(getName()+" "+i);
        }
    }
    public static void main(String[] args) throws InterruptedException {
        //启动子线程
        new JoinThread("新线程").start();
        for(int i = 0;i < 100;i++){
            if(i == 20){
                JoinThread jt = new JoinThread("被Join的线程");
                jt.start();
                //main线程调用了jt线程的join方法，main线程必须等jt执行结束才会向下执行
                jt.join();
            }
            System.out.println(Thread.currentThread().getName()+" "+i);
        }
    }
}
```

以上程序中一共有三个线程，在主线程的循环变量i等于20时，启动了名为“被join的线程”的线程，该线程不会和main线程并发执行，main线程必须等待该线程执行结束后才可以向下执行。在名为“被join的线程”执行时，实际上只有两个子线程并发执行，而主线程处于等待状态。

join()方法的三种重载形式:

- join()：等待join的线程执行完成；
- join(long mills)：等待被join的线程最多mills毫秒。如果在mills毫秒内被join的线程还没有执行结束，则不再等待；
- join(long mills，int nanos)：等待被join的线程的时长最长mills毫秒加nanos毫微秒。

### 4.2后台线程

后台线程（Daemon Thread）：在后台运行，任务是为其他线程提供服务。又称“守护线程”或“精灵线程”。如JVM的垃圾回收线程就是典型的后台线程。
- 如果所有的前台线程都死亡，后台线程会自动死亡；
- 前台线程创建的子线程默认是前台线程，后台线程创建的子线程默认是后台线程；
- 将某个线程设置为后台线程必须在该线程启动之前。

### 4.3线程睡眠

Thread类的静态sleep()方法来让正在执行的线程暂停一段时间，并进入阻塞状态。但是他的监控状态依然保持着，当指定的时间到了又会自动恢复到运行状态。在调用sleep()方法的过程中，线程不会释放对象锁。

sleep()方法的两种重载形式：
- static void sleep(long mills):让正在执行的线程暂停mills毫秒，并进入阻塞状态；
- static void sleep(long mills,long nanos)

### 4.4线程让步

yield()方法也是Thread类提供的一个静态方法，它可以让当前正在执行的线程暂停，但它不会阻塞该线程，它只是将该线程转入就绪状态。（yeild()只是让当前线程暂停一下，让系统的线程调度器重新调度一次）。

### sleep()和yeild()的区别

- sleep()方法暂停线程后，会给其他线程执行机会，不会理会其他线程的优先级；而yeild()方法只会给优先级相同或更高的线程执行机会。
- sleep()方法会将线程转入阻塞状态，直到经过阻塞时间才会转入就绪状态；而yeild()方法不会将线程转入阻塞状态，它只是强制当前线程进入就绪状态。
- sleep()方法声明了抛出InterruptedException异常，所以调用sleep()方法要么捕捉该异常，要么显示声明抛出该异常；而yeild()方法则没有声明抛出任何异常。
- sleep()方法比yeild()方法有更好的可移植性，通常不建议使用yeild()方法控制并发线程的执行。

### 4.5改变线程的优先级

在默认情况下，main()线程具有普通优先级，由main()线程创建的子线程也具有普通优先级。
Thread类提供了setPriority(int newpriority)、getPriority()方法来设置和返回指定线程的优先级，newpriority为范围在1~10之间的整数。


## 五、线程同步

### 5.1 线程安全

在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。

### 5.2 同步代码块

java的多线程支持引入同步监视器来解决文件并发访问所造成的线程安全问题；

![title](https://raw.githubusercontent.com/XQLong/Image-Hosting/master/gitnote/2019/08/14/1565792361050-1565792361056.png)

obj就是同步监视器，线程开始执行同步代码块之前，必须先获得对同步监视器的锁定。逻辑：“加锁~修改~释放锁”。

### 5.3 同步方法

synchronized修饰的实例方法称为同步方法，无须指定同步监视器，同步方法的同步监视器就是调用该方法的对象（this）。

### 5.4 释放同步监视器的锁定

线程会在如下几种情况下释放对同步监视器的锁定：
- 当前线程的同步代码块、同步方法执行结束，当前线程即释放同步监视器；
- 当前线程在同步代码块、同步方法中遇到了break、return终止了该代码块、方法的运行，当前线程会释放同步监视器；
- 当前线程在同步代码块、同步方法中出现了未处理的error或exception，导致了该代码块或方法异常结束时，当前线程将释放同步监视器；
- 当前线程执行同步代码块或同步方法时，程序执行了同步监视器对象的wait()方法，则当前线程暂停，并释放同步监视器；

如下情况下，线程不会释放同步监视器：
- 线程执行同步监视器代码块或方法时，程序调用Thread.sleep()、Thread.yield()方法来暂停当前线程的执行，当前线程不会释放同步监视器；
- 线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放同步监视器。

### 5.5 同步锁

从Java5开始，Java提供了一种更强大的线程同步机制——通过显示定义同步锁对象来实现同步，在这种机制下，同步锁由Lock对象充当。在实现线程安全的控制中，比较常用的是Reentrantlock(可重入锁)。

### 5.6 死锁

当两个线程相互等待对方释放同步检测器时就会发生死锁。

## 六、线程通信

### 6.1 传统的线程通信

借助Object类提供的wait(）、notify（）和notifyAll（）三个方法。这三个方法必须由同步监视器对象来调用。
- wait():导致当前线程等待，直到其他线程调用同步监视器的notify()方法或notifyAll()方法来唤醒该线程（进入就绪状态）；
- notify():唤醒在此同步监视器上的单个线程；
- notifyAll()：唤醒在此同步监视器上等待的所有线程；

### 6.2 使用Condition控制线程通信

如果程序不使用synchronized关键字来保证同步，而是直接使用lock对象来保证同步，则系统中不存在隐式的同步监视器，也就不能使用wait()、notify()、notifyAll()方法进行线程通信了。

当使用lock对象来保证同步时，Java提供了一个Condition类来保持协调，使用Condition可以让那些已得到lock对象却无法继续执行的线程释放lock对象，Condition对象也可以唤醒其他处于等待状态的线程。

Condition对象被绑在一个Lock对象上，

 ![title](https://raw.githubusercontent.com/XQLong/Image-Hosting/master/gitnote/2019/08/15/1565838028559-1565838028847.png)

Condition类提供了await()、signal()、signAll()三个方法。

### 6.3 使用阻塞线程（BlockingQueue）控制线程通信

虽然BlockingQueue也是Queue的子接口，但它的主要作用并不是作容器，而是作为线程同步的工具。

BlockingQueue的特征：
- 当生产者线程试图向BlockingQueue中放入元素时（put()），如果该队列已满，则该线程被阻塞；
- 当消费者线程试图从BlockingQueue中取出元素时（take())，如果该队列已空，则该线程被阻塞；
- BlockingQueue超过容量时，put()方法尝试放入元素会造成线程阻塞；如果使用add()方法尝试放入元素会引发异常；如果使用offer()方法尝试放入元素则会返回false，元素不会被放入。
- BlockingQueue为空时，take()方法尝试取出元素时会造成线程阻塞；使用remove()方法会引发异常；使用poll()方法将返回false，元素不会被删除。

## 七、线程组合未处理异常

Java使用ThreadGroup来表示线程组，它可以对一批线程进行分类管理，Java允许程序直接对线程组进行控制。

在默认情况下，子线程和创建它的父线程处于同一个线程组内。一旦某个线程加入了指定的线程组后，该线程将一直处于该线程组内，指导该线程死亡，线程运行中途不能改变它所属的线程组。

如果线程执行过程中抛出了一个未处理异常，JVM在结束该线程之前会自动查找是否有对应的Thread。UncaughtExceptionHandler对象，如果找到该处理器对象，则会调用该对象的uncaughtException(Thread t,Throwable e)方法来处理该异常。

## 八、线程池

系统启动一个新的线程成本是比较高的，因为它涉及与操作系统的交互。在这种情况下使用线程池可以很好地提升性能，尤其是当程序中需要创建大量生存期很短的线程时，更应该考虑使用线程池。

线程池在启动时即随机产生大量空线程，程序将一个Runnable对象或Callable对象传给线程池，线程池会启动一个线程来执行他们的run()或call()方法，当run()或call()方法执行结束后，该线程不会死亡，而是再次返回线程池中成为空闲状态，等待执行下一个Runnable对象的run()或call（）方法。

## 九、线程相关类

### 9.1 ThreadLocal类

通过把数据放在ThreadLocal类中，就可以让每个线程创建一个该线程变量的副本，从而避免并发访问的线程安全问题。

ThreadLocal将需要并发访问的样本复制多份，每个线程拥有一份资源，每个线程都拥有自己的资源副本，从而也就没有必要对该变量进行同步了。

ThreadLocal并不能代替同步机制，两者面向的问题邻域不同。同步机制是为了同步多个线程对相同资源的并发访问，是多个线程之间进行通信的有效方式；而ThreadLocal是为了隔离多个线程的数据共享，从根本上避免多个线程对共享资源（变量）的竞争，也就不需要对多个线程进行同步了。

### 9.2 concurrent

java.util.concurrent(J.U.C)大大提高了并发性能，AQS被认为是J.U.C的核心。AQS（Abstract Queue Synchronizer），即队列同步器。它是构建锁或其他同步组件的基础框架。

CountDownLatch

用来控制一个线程等待多个线程：

![title](https://raw.githubusercontent.com/XQLong/Image-Hosting/master/gitnote/2019/08/15/1565856031538-1565856031545.png)

维护了一个计数器cnt，每次调用countDown()方法会让计数器的值减1，减到0的时候，那些因为await()








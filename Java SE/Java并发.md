# Java并发

## 线程概述

进程是处于运动过程中的程序，是系统进行资源分配和调度的一个独立单元。具有如下特征：

- 独立性
- 动态性
- 并发性：多个进程可在单个处理器上并发执行，多个进程间不互相影响。

线程也被称为轻量级进程，线程是进程的执行单元。线程的执行是抢占式的；一个线程可以创建和撤销另一个线程，同一个进程中多个线程可以并发执行。

## 线程的创建和启动

### 通过继承Thread类

- 定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务。因此把run()方法称为线程的执行体；
- 创建子类的实例，即创建了线程对象；
- 调用线程对象的start()方法来启动该线程；

使用继承Thread类的方法来创建线程时，多个线程之间无法共享线程类的实例变量。

### 实现Runnable接口
- 定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法同样是线程的执行体；
- 创建Runnable实现类的实例，并以此作为Thread的Target来创建Thread对象，该Thread对象才是真正的线程对象；
- 调用线程对象的start()方法来启动该线程。

采用Runnable接口的方式创建的多个线程可以共享线程类的实例变量（多个线程共享线程的target）。

### 使用Callable和Future
- 创建Callable接口的实现类，并实现Call()方法，该call()方法将作为线程执行体，且该caLL()方法有返回值，再创建Callable类的实例；
- 使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()返回值；
- 使用FutureTask对象作为Thread的target来创建并启动新线程；
- 调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。

### 创建线程的三种方法的对比

实现Runnable和Callable接口的方式基本相同，知识Callable接口定义的方法有返回值，可以声明抛出异常。可以将实现Runnable接口和实现Callable接口归为一类方式。

实现Runnable、Callable接口方式创建多线程的优缺点：

- 线程类只实现了Runnable和Callable接口，还可以继承其他类；
- 在这种方式下，多个线程可以共享一个target对象，所以非常适合多个线程同时处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。

采用继承Thread类的方式创建多线程的优缺点：

- 劣势是因为线程类已经继承了Thread类而不能再继承其他类；
- 优势是编写简单，可直接使用this获取当前线程。

## 线程的生命周期

![title](https://raw.githubusercontent.com/XQLong/Image-Hosting/master/gitnote/2019/08/14/1565785133309-1565785133663.png)

### 新建和就绪状态

当程序使用new关键字创建了一个线程后，该线程就处于新建状态，此时它和其它java对象一样，仅仅由Java虚拟机为其分配内存，并初始化其成员变量的值。此时的线程对象没有表现出任何线程的动态特征，程序也不会执行线程的执行体。

当线程对象调用了start()方法后，该线程就处于就绪状态，Java虚拟机会为其创建方法调用栈和程序计数器，处于这个状态中的线程并没有开始运行，只是表示该线程可以运行了。至于何时开始运行取决于JVM里线程调度器的调度。

### 运行和阻塞状态

如果处于就绪状态的线程得到了CPU，开始执行run()方法中线程的执行体，则线程处于运行状态。当一个线程开始运行后，它不可能一直处于运行状态（除非线程的执行时间足够短，瞬间就执行结束了），线程在执行过程中会被中断，目的是使其他的线程得到执行的机会，线程的调度细节取决于底层平台采用的策略。

如果发生如下情况时，线程会进入阻塞状态：

- 线程使用sleep()方法主动放弃所占用的处理器资源；
- 线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞；
- 线程试图获得一个同步监视器，但该同步监视器正被其他线程所持有；
- 线程在等待某个通知（notify）；
- 程序调用了线程的suspend()方法将线程挂起。但这个方法容易导致锁死，应尽量避免使用该方法。

当发生如下的定情况时可以解除上面的阻塞，让线程重新进入就绪状态：
- 调用sleep()方法的线程已经过了指定的时间；
- 线程调用的






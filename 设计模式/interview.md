# 介绍一下如何实现动态代理?

代理模式属于一种结构型（描述如何将类或对象结合在一起形成更大的结构）的设计模式，在某些情况下客户端不想或不能直接引用一个对象，此时使用代理来控制对原对象的引用，代理对象在客户端和目标对象之间起到中介的作用。

- 静态代理需要为现有的每一个主题类编写一个对应的代理类，代理类是在编译时就实现好的；
- 而动态代理则是在运行时自动生成的，即Java编译完之后并没有实际的class文件，而是在运行时动态生成的类字节码，并加载到JVM中。

Java实现动态代理的大致步骤如下：

1. 定义一个委托类和公共接口；
2. 定义一个调用处理器类实现Invocation接口，这个类的目的是指定运行时将生成的代理类需要完成的具体任务（包括Preprocess和Postprocess），即代理类调用任何方法都会经过这个调用处理器类；
3. 生成代理对象，需要为它指定：（1）委托对象；（2）实现的一系列接口；（3）调用处理器类的实例。因此可以看出一个代理对象对应一个委托对象，对应一个调用处理器实例。
4.Java 实现动态代理主要涉及以下几个类：(1)java.lang.reflect.Proxy: 这是生成代理类的主类，通过 Proxy 类生成的代理类都继承了 Proxy 类，即 DynamicProxyClass extends Proxy;(2)java.lang.reflect.InvocationHandler: 这里称他为"调用处理器"，他是一个接口，我们动态生成的代理类需要完成的具体内容需要自己定义一个类，而这个类必须实现 InvocationHandler 接口。

# 介绍一下单例模式？再说说懒汉式的单例模式如何实现单例？

单例模式是一种创建型设计型模式，即保证类仅有一个实例，并提供一个访问它的全局访问点。单例模式只有一个实例、共享资源，全局使用节省创建时间。懒汉式的单例模式主要包括：
（1）一个私有静态类变量，并将其延迟实例化以保证在使用到时才会被实例化；
（2）一个私有的构造方法，以防止在外部通过构造函数创建多个实例；
（3）一个全局静态方法来实例化并返回实例。

# 请介绍一下策略模式？

策略模式是一种行为型设计模式（不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用），策略模式将定义的一系列算法封装起来，并让它们可以相互替换，角色包括抽象策略类（Subject）、具体策略类（ConcreteSubject）、环境（Context）三个角色。
                                                                                                                                    
